//! Node information types for Slurm cluster nodes.
//!
//! This module contains the data structures for representing node information
//! from Slurm's sinfo command, including state, resources, and GPU information.

use serde::{Deserialize, Serialize};

use super::state::{define_state_checkers, NODE_STATE_PRIORITY};
use super::time::TimeValue;

/// Node information from sinfo
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct NodeInfo {
    #[serde(rename = "nodes")]
    pub node_names: NodeNames,

    #[serde(rename = "node")]
    pub node_state: NodeState,

    #[serde(rename = "partition")]
    pub partition: PartitionInfo,

    pub cpus: CpuInfo,
    pub memory: MemoryInfo,

    #[serde(default)]
    pub gres: GresInfo,

    #[serde(default)]
    pub sockets: MinMaxValue,

    #[serde(default)]
    pub cores: MinMaxValue,

    #[serde(default)]
    pub threads: MinMaxValue,

    #[serde(default)]
    pub features: FeatureInfo,

    #[serde(default)]
    pub reason: ReasonInfo,

    #[serde(default)]
    pub weight: MinMaxValue,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct NodeNames {
    #[serde(default)]
    pub nodes: Vec<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct NodeState {
    #[serde(default)]
    pub state: Vec<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct PartitionInfo {
    pub name: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct CpuInfo {
    #[serde(default)]
    pub allocated: u32,
    #[serde(default)]
    pub idle: u32,
    #[serde(default)]
    pub total: u32,
    pub load: MinMaxValue,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct MemoryInfo {
    #[serde(default)]
    pub minimum: u64,
    #[serde(default)]
    pub allocated: u64,
    #[serde(default)]
    pub free: MemoryFreeInfo,
}

#[derive(Debug, Clone, Default, Deserialize, Serialize)]
pub struct MemoryFreeInfo {
    pub minimum: TimeValue,
    #[serde(default)]
    pub maximum: TimeValue,
}

#[derive(Debug, Clone, Default, Deserialize, Serialize)]
pub struct GresInfo {
    #[serde(default)]
    pub total: String,
    #[serde(default)]
    pub used: String,
}

#[derive(Debug, Clone, Default, Deserialize, Serialize)]
pub struct MinMaxValue {
    #[serde(default)]
    pub minimum: u64,
    #[serde(default)]
    pub maximum: u64,
}

#[derive(Debug, Clone, Default, Deserialize, Serialize)]
pub struct FeatureInfo {
    #[serde(default)]
    pub total: String,
}

#[derive(Debug, Clone, Default, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ReasonInfo {
    #[default]
    Empty,
    String(String),
    Object {
        #[serde(default)]
        description: String,
    },
}

impl ReasonInfo {
    #[must_use]
    pub fn description(&self) -> &str {
        match self {
            ReasonInfo::Empty => "",
            ReasonInfo::String(s) => s.as_str(),
            ReasonInfo::Object { description } => description.as_str(),
        }
    }
}

/// GPU information parsed from node GRES
#[derive(Debug, Clone, Default)]
pub struct GpuInfo {
    pub total: u32,
    pub used: u32,
    pub gpu_type: String,
}

impl NodeInfo {
    #[must_use]
    pub fn name(&self) -> &str {
        self.node_names
            .nodes
            .first()
            .map(|s| s.as_str())
            .unwrap_or("")
    }

    /// Get the partition name (preserves original casing from Slurm)
    #[must_use]
    pub fn partition_name(&self) -> String {
        self.partition
            .name
            .clone()
            .unwrap_or_else(|| "unknown".to_string())
    }

    // ========================================================================
    // Node State Checkers
    // Generated by the define_state_checkers! macro to reduce boilerplate.
    // Based on official Slurm node state documentation.
    // ========================================================================

    /// Check if node has any of the specified states
    fn has_state(&self, states: &[&str]) -> bool {
        self.node_state
            .state
            .iter()
            .any(|s| states.iter().any(|state| s == *state))
    }

    define_state_checkers! {
        // Operational states (with short code variants)
        is_allocated => ["ALLOCATED", "ALLOC"],
        is_completing => ["COMPLETING", "COMP"],
        is_idle => ["IDLE"],
        is_mixed => ["MIXED", "MIX"],

        // Critical states
        is_down => ["DOWN"],
        is_fail => ["FAIL"],
        is_failing => ["FAILING", "FAILG"],
        is_inval => ["INVAL"],

        // Maintenance/administrative states
        is_drained => ["DRAINED"],
        is_draining => ["DRAINING", "DRAIN", "DRNG"],
        is_maint => ["MAINT"],
        is_reserved => ["RESERVED", "RESV"],
        is_blocked => ["BLOCKED"],

        // Reboot states
        is_reboot_requested => ["REBOOT_REQUESTED"],
        is_reboot_issued => ["REBOOT_ISSUED"],

        // Power states
        is_power_down => ["POWER_DOWN", "POW_DN"],
        is_powered_down => ["POWERED_DOWN"],
        is_powering_down => ["POWERING_DOWN"],
        is_powering_up => ["POWERING_UP", "POW_UP"],

        // Special states
        is_perfctrs => ["PERFCTRS", "NPC"],
        is_planned => ["PLANNED", "PLND"],
        is_future => ["FUTURE", "FUTR"],
        is_cloud => ["CLOUD"],
        is_unknown => ["UNKNOWN", "UNK"],
    }

    /// Get the primary node state for display.
    ///
    /// Uses `NODE_STATE_PRIORITY` to determine which state to show when
    /// multiple states are present. Returns the first matching state
    /// in priority order, or falls back to the first state in the array.
    #[must_use]
    pub fn primary_state(&self) -> &str {
        for (display, variants) in NODE_STATE_PRIORITY {
            if self.has_state(variants) {
                return display;
            }
        }
        // Fallback
        self.node_state
            .state
            .first()
            .map(|s| s.as_str())
            .unwrap_or("UNKNOWN")
    }

    /// Get node reason description
    #[must_use]
    pub fn reason_description(&self) -> &str {
        self.reason.description()
    }

    #[must_use]
    pub fn memory_total(&self) -> u64 {
        self.memory.minimum
    }

    #[must_use]
    pub fn memory_free(&self) -> u64 {
        self.memory.free.minimum.number()
    }

    #[must_use]
    pub fn memory_utilization(&self) -> f64 {
        if self.memory.minimum == 0 {
            0.0
        } else {
            let free = self.memory.free.minimum.number();
            let used = self.memory.minimum.saturating_sub(free);
            (used as f64 / self.memory.minimum as f64) * 100.0
        }
    }

    /// Parse GPU information from GRES string
    #[must_use]
    pub fn gpu_info(&self) -> GpuInfo {
        let mut gpu_info = GpuInfo {
            total: 0,
            used: 0,
            gpu_type: String::new(),
        };

        // Parse total GPUs from format: "gpu:l40s:4(S:0-1)"
        if self.gres.total.contains("gpu:")
            && let Some(gpu_part) = self.gres.total.split("gpu:").nth(1)
        {
            let parts: Vec<&str> = gpu_part.split(':').collect();
            if parts.len() >= 2 {
                gpu_info.gpu_type = parts[0].to_string();
                if let Ok(count) = parts[1].split('(').next().unwrap_or("0").parse::<u32>() {
                    gpu_info.total = count;
                }
            }
        }

        // Parse used GPUs from format: "gpu:l40s:3(IDX:0-2)"
        if self.gres.used.contains("gpu:")
            && let Some(gpu_part) = self.gres.used.split("gpu:").nth(1)
        {
            let parts: Vec<&str> = gpu_part.split(':').collect();
            if parts.len() >= 2
                && let Ok(count) = parts[1].split('(').next().unwrap_or("0").parse::<u32>()
            {
                gpu_info.used = count;
            }
        }

        gpu_info
    }
}
